# bitcamp-20201221
[9일차]
1.프로 젝트 임포트 하기까지 추가해야하는것 정리
폴더를 만든다 > git ignore 파일을 넣어준다 > github에 폴더를 만든다 
 > git clone 주소를 해준다. 
 > gradle init 을 해줘서 설정해준다 > build.gradle 파일에서 id java id eclipse 
   UTF-8 설정 , 이름 바꾸기, mainclass 이름을 설정 해준다 > cmd에서 gradle eclipse 해준다
 >이클립스에서 import 해주기 > README를 resources 와 test에 넣는다.

2.gitignore 파일에 추가 해야할것 정리
gitignore에 java linux java web visual studio code node eclipse window macos gradle 
추가하고 
.project에 있는 #지우고 .classpath 추가
맨 마지막에
*.exe  
node_modules/
temp/
Debug/
Release/
html-exam/ 

3. 개발 환경 셋팅법
자바 스크립트 다운 받는곳 : nodejs.org   node-v 구버젼 다운받기 
mingw (1,2,7)다운  cmd에서 gu install native-image 로 설치
graalvm.ce.java에서 11버젼 다운(11버젼을 많이씀)
자바 환경 변수 설정 path에 추가하고 새로 만들기에서 11버젼 bin까지 들어가주기
이클립스 develope 다운   naver d2 coding 글꼴 다운 
git hub eclipse java google style xml 다운


[10일차]
컴파일 방식 : jvm이 이해할 수 있는 중간 언어로 바꿔준다 < 유사 기계어로 보자
인터프리터 방식: 소스코드를 한 문장씩 읽고 기계어로 바꿔준다
하이브리드 방식: 두개를 섞은것 소스코드를 바이트 방식으로 변경하고 그 코드를 한 줄씩 읽는 방식

GUI : 그래픽 유저 인터페이스 > 흔히 우리가 아이콘을 클릭하여 프로그램 작동시키는
CLI : 명령 줄 인터페이스 > 작업 명령을 키보드로 입려하여 컴퓨터가 출력해주는것 ( 문자열만 가능)

파월쉘과 프롬프트 차이점: 파월쉘은 cmd의 업그레이드 버전이라고 보면 된다 더 체계적임

해시 값/디지털 지문: 파일 특성을 축약한 문자와 숫자의 조합 

[11일차]
빌드 도구가 하는일: 라이브러리의 버전을 동기화 ,중앙 저장소에 저장하여 관리함 
빌드 도구는 ant maven gradle이 있음


[13일차]
1의 보수: 입력값의 반전된 값 
2의 보수: 1의보수 +1
excess-k: k=2n-1로 
[14일차]
인코딩을 쓰지 않으면 컴퓨터가 어느 나라 언어인지 인식을 못함 그래서 -encoding을 사용
인코딩: 소스파일을 인코딩 하여 번역해주는거 
디코딩: 인코딩에 반대

래스터 방식: 점의 배열로 이미지 표현
벡터 방식:  실제로 이미지에 표현되는 점에 대한 정보를 저장하여 이미지를 표현한다
해상도를 변경해도 이미지 손상이 나지 않음.

변수란 값을 저장할 메모리 공간
원시 변수 : 데이터 타입 float double int 
레퍼런스 변수: 실제값이 아닌 주소 값을 가르키는 변수
jvm 문자 다루는 방식 유튜브 참조 

[15일차]
시스템 소프트웨어:컴퓨터의 작업을 돕기위해 여러가지 프로그램으로 구성된것
ex) 텍스트에디터 컴파일러 파워셀 디버거  
애플리케이션 소프트웨어: 컴퓨터를 문제 해결을 위한 도구로 활용하는것

프로젝트 폴더 만들기 : 
카톡 참고하기

형상관리 시스템: 프로젝트를 진행하면서 git같은 시스템을 이용하여 다수의 개발자가 이용하여
협업하는 시스템
필요한 이유: 소스 코드의 변경 사항을 보존하기 위해
버그 및 문제점 발생시 추적 가능
백업을 했다면 과거에 있는 소스도 확인 가능 
협동 작업을 위해서

가비지 컬렉터: 메모리가 부족하여 주소를 잃어버려서 사용할수 없는 메모리가 되는것

[16일차]
.git/ 폴더 용도: 백업 폴더 이 폴더를 지우면 백업이 불가능하다 지우지 않도록 조심하자
로컬저장소에 백업하는법: 백업할 폴더를 만들고 거기에 시키는대로 하자
저장소와 원격 저장소 연결법 : git remote add 이름 주소 
git add . git commit -m "백업할 이름 " git push로 저장

import java.util.Scanner;
Scanner scanner = new Scanner(System.in);으로 키보드 입력 사용 가능

class란 그 파일을 담을 틀같은 존재
인스턴스란 객체를 소프트웨어에 실체화 한것 
[17일차]
자바에서 제공하는 연산자 순서대로 
[] , .  << ()++ ()-- <<++() --() + - ~ ! (type) << * / % << + - << ( << >> >>>) << < > <= >= << == !=

암시적 형변환 : 더 큰 데이터타입이 작은 데이터 타입이랑 계산할때 큰 데이터타입이 작은데이터 타입을 바뀌는것
명시적 형변환 : 자동 형변환이 일어나지않을때 강제로 바꿔주는것 ex) int b = (int) 10.0F 
부동소수점 비교: cpu나 컴파일러에 따라 값이 다르고 2진수 변환하면 무한 반복하기 땜에 뒤에 값이 다를수 있음

논리 연산자 : &&=and ||=or !=not ^=xor 서로 다를때 1반환 & ,&& 차이는 
&&이 왔을때 앞에 계산이 false이 떳으면 뒤에 계산은 하지않는다 
&이 왔을때는 앞에 계산이 false가 떠도 뒤에 값을 계산한다. 

비트 연산자 :  2<<3 이란 3칸을 앞으로 떙겨 곱으로 만드는거
                  16>>3 이란 3칸을 뒤로 떙겨 분해하는거 앞은 0으로 채움
                   연산을 한번만 할 수 있어서 속도가 매우 빠름.
특정 값을 차단하여 원하는 색을 만들수 있음.
음수를 3칸이동하면 이상한값이 나온다.
 

[18일차]
if를 쓰고 if else 를 쓰고 마지막으로 else로 마무리 
엔트리 포인트란 자바 프로그램의 시작지점이다 >> main() 메서드
[19일차]

자바 홈과 패스를 설정하는 이유는 컴파일을 할때 일일이 경로를 지정해주기가 힘들어서 
패스를 설정하므로써 고생을 덜어준다 

build gradle에서 eclipse { 
                      project {
                    name = "myproject"
             }
         }

메서드: 코드를 관리하기 쉽고 재사용하기 좋게 기능 단위로 묶어 놓는 문법
 반복적으로 자주 사용하는 명령어를 재사용하기 위해 묶어놓은 것 

메서드 시그니처 : 메서드명, 변수선언 
메서드 몸체 : 메서드 블록
파라미터: 메서드를 정하고 안에 들어있는 변수 
아규먼트: 그 변수의 값들

메서드 문법 사용 이점 : 메서드를 사용하면 기능별로 묶여 있어 유지보수가 쉬워지고 
                              반복적으로 사용할때 시간을 절약 할 수 있음.

리팩토링: 코드 짠걸 더 나은 디자인으로 개선하는거 
            보기 좋게 만드는걸 의미한다.
[20일차]
메서드
자료형 이름 (변수명, 변수명) {
    행위;
}
메서드 호출
객체 이름.메서드 이름();

파라미터: 전달되는 값을 넘겨 받을 때 쓰이는 변수
아규먼트: 함수에 전달 되는 실제의 의미 있는 값 

Call by value는 메서드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값(value)을 복사하여 보낸다.
Call by reference는 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 주소(Address)를 복사하여 보낸다.

클래스에서 메서드 호출 방법
내부 : 타입 변수 = 메서드(값)
외부 : 클래스 참조변수 = new 클래스(매개변수);

[21일차]
객체란 표현할수 있는 속성과 동작으로 이루어진것 
인스턴스란 객체를 생성하여 메모리에 적재하는것
레퍼런스: 인스턴스를 가르키는 값
[22일차]
DAO : DB를 사용해 데이터 조회 조작 기능
DTO 또는 VO :계층 간의 데이터 전달에 사용하는 데이터 객체 
static:
공간적 특성: 멤버는 클래스당 하나가 생성된다
시간적 특성: 클래스 로딩 시에 멤버가 생성된다

static 메서드는 오직 static 멤버만 접근 가능
this 키워드를 사용할 수 없다
[23일차]
클래스 로딩: 하위 클래스는 상위 클래스에게 로딩 위임
하위 클래스는 상위 크래스를 바라볼 수 있지만 그 반대는 안된다.

스택: 원시 타입의 데이터들이 할당되고 실제 값을 직접 저장
힙 : 단 하나의 힙 영역만 존재 레퍼런스 변수가 스택에 올라가게 된다
스태틱으로 선언 되지 않은 모든 변수는 인스턴스 필드
스태틱으로 선언 되지 않은 모든 메소드

인스턴스 메서드의 this는 자기 자신을 가르킨다
[24일차]
Reference Counting은 객체, 메모리 블록, 디스크 공간 등을 참조하는 Reference, Pointer, Handle 의 갯수를 저장하는 기술이다
[25일차]
생성자는 객체를 생성시 바로 값을 가지게 한다.
this()의 사용법은 인스턴스 멤버인 필드를 명시하고자 할떄 사용한다
, 다른 생성자를 생성할때 첫 문장으로 쓴다
static {          // <<<< static 초기화문 
    //수행문;
    }
인스턴스 초기화 블록 용도 : 인스턴스 필드 초기화 시킬때
[26일차]
@Deprecated : 사라질수 있으므로 사용을 자제해달라는 의미이다.
window 기본 character set은 ms 949 
private protected 는 접근 제한 
[27일차]
extract method : 메서드 추출 리팩토링
replace temp with query` : 마틴 파울러 리팩토링에서 보도록하자
[28일차]
배열의 크기 늘리기 미니 프로젝트 참고
linked-list : 노드와 링크로 구성 각 노드들을 연결해서 구현
배열 : 여러개의 데이터를 인덱스에 저장하는 방식
[29일차]
클래스를 분리할떄 이점: 오류를 쉽게 찾고 추가 변경이 쉽다.
[30일차]
추상화 : 필요한 정보들만 간추려서 적는거
캡슐화 : 객체의 필드와 메서드를 한곳으로 묶고, 실제 구현 내용을 외부에 감추는곳
접근자를 한곳에 묶는것을 property라고 한다
상속 : 부모 클래스로 부터 물려받는거 
장점 : 중복 코드를 줄일 수 있다.
오버로딩 : 부모에게 상속 받은 것을 재정의 하는것
오버라이딩 : 상속 관계간의 이름을 정의하는 것
[31일차]
슈퍼클래스를 지정하지 않으면 Object가 슈퍼 클래스가 된다.
toString() : 슈퍼클래스인 Object의 메서드이다.
 클래스명과 해쉬값을 문자열로 리턴함 
 equals() : 인스턴스 내용이 같을떄 확인 하는법
 hashCode() : equals와 마찬가지로 값을 비교할 때 사용
 오버라이딩 : 상속 받은 메서드를 수정하고 싶을 때
 [32일차]
immutable : 값을 담으면 변경할 수 없다 (String객체)
mutable : 원래의 문자열을 변경하고 싶을 떄 사용 (StringBuffer)
 super() : 부모 클래스의 생성자를 호출하기 위해서 사용
 wrapper : primitive 값을 포함하여 모든 값을 쉽게 주고 받기 위함이다.
 리터럴로 만든 String 객체는 문자표기를 하지 않으면 문자가 깨져서 출력된다.
 다중 상속 안하는 이유 : 어떤 슈퍼클래스의 메서드를 오버라이딩 할려는지 모르기떄문
 추상 클래스 : 어떤 기능을 수행할지 모를때 사용 abstract 사용 
            자식 클래스에게 반드시 오버라이딩 해야한다.
 추상 메서드 : 자식 클래스가 부모 클래스를 구현 안할시 반드시 구현하게 만듬
[33일차]
다형적 변수 :  그 클래스의 서브클래스 객체까지 가리킬 수 있다.
            두 개의 클래스가 같은 조상을 가르킬 떄 사용
instance of를 사용하여 레퍼런스에 들어있는 주소가 특정 클래스의 인스턴스인지 검사
final 접근제한자 클래스명 >> final 클래스 사용시 상속 불가
[42일차]
throws: 메서드 호출시 예외를 발생시키고 싶을 경우에만 해당한다.
Exception : try catch로 잡아줘야 한다 그렇지 않으면 컴파일 오류 발생
RuntimeException : 프로그램 오류로 발생하므로 try catch를 사용 안해도 괜찮다.
try-with-resources : close() 메서드를 자동으로 호출해서 자원을 해제시켜준다
finally : 예외 발생과 상관없이 무조권 실행 시킨다.
[43일차]
제네릭: 타입을 미리 지정해주는 것이 아닌 사용자가 값을 지정해주는 것
wildCard<?> : 어떤 타입이든 상관이 없다 (되도록이면 쓰지 말자)
extend 자손 타입만 가능 super 조상 타입만 가능
Runnable : 인자 x 리턴 x Supplier 인자 x 리턴 T 
Consumer : 인자 T 리턴 x   Function 인자 T 리턴 R
Predicate : 인자 T 리턴 boolean
람다 문법은 참고하기 
(매개변수, ...) -> { 실행문 ... }

인스턴스 메서드 레퍼런스 : Function<String, Boolean> f = String::isEmpty;
Boolean result = f.apply("123");
생성자 메서드 레퍼런스 : Supplier<String> s = String::new;



[44일차]
binary file : 전용 app 사용, 특정 형식으로 인코딩 ,생성 변경시 전용 앱 필요
ex) class psd pdf jpeg gif lib 
text file: character set 규칙에 따라 인코딩 , 일반 텍스트 편집기로 생성 변경 가능
ex) docx xlsx ppt c gradle md xml java

sink 타입(직접 읽고 쓰는 클래스)
: FileOutputStream, ByteArrayOutputStream,PipedOutputStream
중간에서 데이터 가공
: BufferedInputStream,DataInputStream,ObjectInputStream
FileInputStream은 바이트단위로 처리를 하고, FileReader는 문자단위로 처리를 한다
인코딩 그 컴퓨터에 맞게 호환성을 바꿀 수 있다 .
java api : 사용자가 쉽게 구현할수 있도록 자바에서 지원해주는것 
데이터 프로세싱 스트림 클래스: 입출력 중간에 데이터 가공해주는 역활

byte를 리턴하면 끝을 나타나는게 없으므로 int로 리턴 
음수의 경우 맨 좌측 비트가 1이 되어 값이 꼬인다.

버퍼 : 속도를 빠르게 해주기 위해 사용 보통:8096byte
[45일차]
상속을 이용하여 입출력 기능을 하면 다중 상속이 불가능하고 코드가 중복이 되는 문제점이 있다.

포함 관계로 기능 확장: 중간에서 데이터를 가공해준다 ex) input 과 ouput으로 나누기
데코레이터 패턴 이란? 바이트 단위 파일 입력 스트림, 보조적으로 받는 스트림을 사용
기능 구현(내 프로젝트 기준) : DataInputStream BufferedInputStream을 묶어서 데코레이터로 사용

ObjectInputStream : 객체의 직렬화 
직렬화 : 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 바꾸는기술
serialVersionUID : 역 직렬화 과정에서 값이 맞는지 확인 할때 쓰는거 필수는 아니다.

예외 처리 : 시스템 예외(Error) : JVM에서 발생하여 개발자가 처리할 수 없는거
ㄴ적적히 안내 메세지를 띄우거나 log 파일을 남기고, 
  현재 작업 중인 데이터를 백업한 후
  애플리케이션 종료

애플리케이션 예외(Exception) : 개발자가 처리 가능
  ㄴ 오류에  대한 적절한 조치를 취한 후
      애플리케이션을 실행한다.

throw 예외객체;
          ㄴ Throwable 객체
                 ㄴ 보통 애플리케이션 예외 객체를 던진다
                            ㄴ 즉 Exception 객체

예외 처리 
ty { 
예외를 던지는 메서드 호출 or throw 명령을 사용하여 명시적으로 예외를 던질 때 
} catch ( 예외객체를 받는 파라미터} {
예외 처리 코드 }

예외 처리를 호출자에게 위임하기

void m1() throws 예외 클래스, 예외 클래스, ....{
    예외 발생 코드 <- m1()을 호출한 쪽에서 예외를 처리해야한다.
}

try fianll 을쓰면 catch없이 쓸 수있다.

예외를 던지면 받아야한다.

Exception : 개발자에게 예외를 강조한다.
RuntimeException : 예외 처리 강조를 하지 않는다.
[46일차]
바이너리 파일 : 텍스트 파일 이외에 모든 실행 파일
텍스트 파일 : 글자로 이루어준 파일
Text File > 일반 텍스트 편집기로 변경 (csv, html , css,js) 가 있다 .
          byte Strean class                             character Stream class                                               
  inputStream  outputStream                            writter reader  
File         File(input,output)Stram                        File(wrieer,reader) 
            Byte Array-                                        charArray , String
              piped                                              piped

FileInputStream , FileOutputStream : 바이트 단위로 출력할 수 있는 클래스
InPutStreamReader : 바이트 기반을 스트림으로 연결
BufferedReader: 버퍼를 사용해서 입출력 효율을 높인다 ( 데이터를 라인 단위로 읽는다)
BufferedInputStream: 입출력 효율을 높이기 위해 사용(한 번에 여러 바이트 입출력 가능)
DataInputStream: 데이터를 바이트 스트림으로 입출력하게 해준다
Stream api 등장 전  각 장비마다 API의 사용법이 달라서 프로그래밍이 불편했다
Streaming 기법 H/W에 상광넚이 입출력 프로그래밍이 가능 

메모리를 마음대로 준비 하면 안되는 이유: 서버를 관리 하기 때문


[47일차]

writer/reader을 쓸때 문자열 처리를 자동 수행한다.

FileWrite UTF-8로 설정해서 출력해준다
  ㄴ 앞의 2바이트는 버리고 뒤의 2바이트는  UTF-8로 변환되어 출력
인터페이스 : 기능에 대해서만 선언 한 상태 모든 기능을 추상화로 정의한 것
제네릭 문법 : 타입을 저해서 캄파일시 에러를 방지 하는것, 불필요한 타입 변화를 막는다
[48일차]
메타 데이터 : 데이터를 설명하는 데이터 (마크업=부가데이터=태그 같인용어 )
ex) XML,HTML
CSV : 콤마로 데이터 구분하는 방법
JSON : App간 데이터 교환을 할떄 JSON포멧으로 만든후에 전달
GSON : 역직렬화 해주는거 
Observer :   수동 감시 
객체가 특정 상태에 놓일 떄 어떤 작업을 수행시키고 싶을 경우 
작업의 추가 삭제 

functional interface : 추상메서드가 한 개만 있는 인터페이스 > 람다 문법 적용 가능
일반 클래스  class x .... {}
익명 클래스 new ObjectFactory {}
람다     csvStr -> {}
메서드 레퍼런스 : 클래스명::스태틱    인스턴스::인스턴스메서드    클래스명::new
[49일차]
Networking :한 컴퓨터가 Hub를 통해 다른 컴퓨터들에게 데이터를 줄 수 있음 
데이터를 보내면 모든 컴퓨터에게 다 간다,
router : 경로 알려주는 역활
switch hub : 특정한 컴퓨터에게만 데이터를 줄 수 있음
일반 hub 는 일단 정보를 연결된 컴퓨터에 모두 보내고 받을 컴퓨터만 받는다
gateway : 공유기 같은거

Mac address : ram카드에 있는물리 적인 id= 주소(전부다 id 가 다르다) 

 
 인트라넷 : 내부망 독자적인망(LAN) -> 폐쇄적임망 
WAN : LAN 끼리 묶은 것
Internet : WAN 끼리 묶은 것 

통신 : ip 주소는 16진수로 바꾼뒤 1바이트로 나눈다
ipAddress : 4byte > 최대 약 42억개의 장비에 주소를 부여할 수 있다
         ip 주소거 50억개가 넘어가면서 주소 부족 > 해결하기 위해 private Ip Address가 나옴
                                                                                        ㄴ 공유기 
문제점 : 사설 ip는 데이터를 주고 받을 수가 없다.
모든 장비가 연결되는 상황 > IOT(Internet of Things) > 소형 장비(가로등arduino , Raspberry pi 소형장비)
헤르츠가 높을수록 벽을 뚫을 수가 없다 .

포트 번호란 ? 통신을 접속하기 위한 식별자
port 고정 번호 :  0 ~ 1023 < 유명한 곳들이 사용중 
Https 443 pop3 110     
1024 ~ 49151   < 일반 서버 App이 사용하는 포트 
ㄴ 어떤 포토 번호를 쓸지 개발자가 지정한다
ip address/port : 49152 ~ 65535 동적 번호: os가 임의로 부여 

App1      요청,응답          App2 
요청 하는쪽 : client    응답 하는쪽 : server 
ex) 인터넷 뱅킹 앱   인터넷 뱅킹 서버 
       ATM s/w        
       카톡 메신저            카톡 서버
        네비게이션         네비게이션 서버

ServserSocket 과 Socket 클래스
clien                             ServerSocket
ㄴ socket생성                       ㄴ Server 생성

Socket > getOutputStream() > OutputStream > 데코레이터
            getInputStream() > InputStream > 데코레이터

ServerSocket >> accept()를 하면 Socket 생성 >> 클라이언트축 소켓과 연결됨
      ㄴ 접속 대기열                      ㄴ getOutputStream() > OutputStream > 데코레이터
                                                  getInputStream() > OutputStream > 데코레이터

대기열 : 연결을 끊어도 서버의 대기열에는 클라이언트 정보가 그대로 남아있다.
          클라이언트가 연결을 끊는다고해서 대기열에 빈자리가 생기는 것은 아니다.
해결책: accept()호출 , 대기열에서 클라이언트 정보를 꺼내야한다
[50일차]
Connection-Oriented(연결 지향) : 한번 연결 후 여러 번 데이터 송수신 예) 전화 FTP 
게임 프로토콘
Connectionless(비연결성) : Board casting 데이터 전송 < 특정 목저지를 명시하지 않는다
 예) 편지 , ping
Stateful 방식 : 한번 연결하면 연결을 끊을떄까지 계속 연결 되어 있다.
                온라인 게임을 생각해보자  
Stateless 방식 : 매번 데이터를 송수신 할 때마다 연결 수행 
                114 고객 센터를 생각해보자 
                
therad 개념 : 사용하면 동시에 처리 가능 순서를 가달리지 않아도 된다. 
[51일차]
connectionless : 서버와 연결없이 데이터를 주고 받을 수 있다.
DatagramSocket, DatagramPacket을 사용하여 처리한다.

프로토콜: 클라이언트/서버 간의 통신 규칙
          데이터를 주고 받는 규칙

 HTTP 요청 프로토콜
 --------------------------------
 GET [자원주소] HTTP/1.1 (CRLF)
 Host: [서버주소] (CRLF)
 (CRLF)
[52일차]
통신 프로토콜 : 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다

[56일차]
Hz : 1초당 일어나는 주기적 현상
멀티태스킹 : 여러 작업이 동시에 진행되는 기법

라운드로빈 스케쥴링: 시간 할당량을 정해 cpu를 처리한다.

우선순위 스케쥴링: cpu버스트가 낮을수록 우선 순위 높다 
cpu를 사용하지 못하는 프로세서들이 무한히 기달리게 된다.

컨텍스트 스위칭 :전 스레드의 문맥 정보 (레지스터 값, 실행중인 스택 정보 등)을 백업받고 백업받아 놓았던 다음 스레드의 문맥정보를 로딩하는 과정

[57일차]
비동기 방식으로 할떄 : 은행에서 한 계좌에100만원을 꺼내고자 할때 
 4명이 100만원을 전부 다 꺼낼수 있음.
 critical section : 한번의 하나의 스레드만 접근을 허용하고자 할때 사용함
 (임계 영역)
 thread safe: 여러 스레드를 사용하면 시스템 자원의 사용, 응답시간, Context Switch 횟수를 줄일 수 있다는 장점을 얻을 수 있다. 대신 데이터의 충돌 문제가 발생할 수 있다.

 mutex : 임계영역에 오직 한개의 스레드만 접근 허용 가능
 semaphore(n) : 임계영역에 n개의 스레드 허용 가능
 pooling: 상태를 지속적으로 체크하는 전송 제어 방식

 [58일차]
 DBMS : 서버에 있는 파일 관리를 쉽게 하기 위해서 
 Assembly언어는 cpu에 따라 다르다
 SQL : DBMS에 상관없이 명령어를 작성할 수 있도록 명령 작성 문법을 통일 시킨것
동적 라이브러리 :- 초기 유닉스 시스템의 유일한 라이브러리 형태
정적 라이브러리 :
- 프로그램에 라이브러리릉 링크하면 실행시에 해당 공유 라이브러리가 필요하다는 정보를 기록
- 프로그램 실행 시에 동적 링커가 공유 라이브러리를 메모리에 올리고 모든 프로그램이 이용할 수 있다.

ODBC API : 표준 개방형 응용 프로그램으로써 여러 방면에서 접근 가능하다


[60일차]
주 키: 관리자가 데이터를 구분하는 키(id)로 결정
대안 키: 주 키를 제외한 나머지 키
인공 키: 주 키로 찾을 수 없을때 사용 하는 키
주 키로 설정하는 법: 설정하고 싶은거 옆에 primary key적기
대안키 = unique 주요키 말고 다른 정보를 키로 만들고 싶을때 사용
주키 or 대안키에 auto_increment 를 쓰면 1씩 자동증가 된다
인덱스 : 문자를 정렬시키는것(입력,변경,속도가 느려지는 단점이 있다)
fulltext index추가 시키면 인덱스 컬럼으로 지정된다.
뷰 : 조회 결과를 테이블처럼 사용하는 문법
정규화: 데이터의 중복을 줄이고 무결성을 향상 시키는 등 여러 목적을 달성 
alter table 테이블명   ===> FK 설정
    add constraint 제약조건이름(자식) foreign key (컬럼명) references 테이블명(컬럼명,부모);
트랜잭션: 더 이상 쪼개질 수 없는 업무처리 단위 
한꺼번에 완료되면 .commit 취소가 된 경우 rollback
[61일차]
select all은 모든 데이터를 가져온다 
selectdistinct는 중복 값을 한 개만 추출할때 붙인다.
order by 하고싶은거 desc; (내림차순)  ordeer by bane asc;(오름차순)
as를 사용하여 라벨명으로 사용 (생략 가능)
union: 중복 값 자동 제거
union all: 중복 값 제게 x
cross join 두 테이블의 데이터를 1:1로 모두 연결
문제점: 필요 없는 것도 연결이 되어 버리낟
natural join : 같은 이름을 가진 컬럼 값을 기준으로 레코드 연결
문제점: 컬럼 이름이 다를 때 연결이 안된다, 모든 컬럼의 값이 일치한 경우에만
연결이 된다.
위에 문제 해결 법: outer join 사용
outer inner 차이점 : outer는 배정되지 않은 데이터도 출력을 해준다.
[62일차]
API: 애플리케이션을 제작할때 사용하는 도구
JDBC API : 드라이버 제어와 관련된 클래스 제공, 드라이버 호출 규칙을 인터페이스로 정의
Oracle JDBC Driver : JDBC API 규칙에 따라 클래스를 구현, 모든 JDBC 드라이버는 사용법이 같다.
[63일차]
java.sql.Connection을 쓰면 어떤 인터페이스인지 상관없이 받아 오기만 하면 된다.

visual studio code 가 .classpath를 잘못 덮여 씌워버려서 사려져 버린다
다시 gradle eclipse 해주면 된다.

Resultset Driver가 connection에게 바로 리턴해준다. connection은 statement에게 바로 리턴
satement는 resultset에게 바로 리턴 resultset은 dbms에서 결과 가져옴

CRUD : create , read , update , delete

정리 : Connection 받아와서 DriverManager에게 연결하기 DriverManager는 Driver 객체를 찾는다.
Statement : SQL문을 DBMS의 형식에 따라 인코딩하여 서버에 전달
executeUpdate(): 데이터를 변경할때 사용
executeQuery():  서버에서 데이터 가져오기
ResultSet : 서버에서 결과 가져오기
getString(컬럼번호) : 0이 아닌 1부터 사용한다 헷갈리지 않게 변수명을 쓰도록하자
fk가 걸려있으면 자식 데이터를 먼저 지우자 

SQL 삽입 공격이란? 명령을 삽입하여 프로그램 의도와 다르게 데이터를 조작
해결 방법 : PreparedStatement 사용

Statement.RETURN_RENERATED_KEYS : 자동 생성된 pk값을 받겠다고 설정하는 문법

여러 개의 데이터 변경은 수동으로 해야한다.

setAutoCommit(false) 설정 하는 이유: 한 단위로 작업을 해야할 경우 사용

트랜잭션 : 여러 개의 데이터 변경 작업을 한 단위로 묶는것
          
예시 ) : 모든 주문 업무를 묶어놓음 한개라도 실패하면 실행이 안된다.

커넥션을 공유하는 상황이면 롤백해야한다.

[64일차]

DAO(Data Access Object)란? 데이터 처리 관련 코드를 별도의 클래스로 캡슐화 시키는것 
DTO(Data Transfer Object)란? 여러개의 값을 호출 할 떄 여러 값을 간단히 전달하기 위해 만든 클래스

VO=Domain=DTO 다 같은거



# bitcamp-20201221

## 원격 Git 서버의 저장소 복제하기

```
> git clone https://github.com/eomjinyoung/bitcamp-20201221.git
```

## 작업 파일을 로컬 저장소에 백업하기

백업 명단 작성
```
> git add .
```

로컬 저장소에 백업
```
> git commit -m "백업에 대한 간단한 내용"
```

## 로컬 저장소의 변경된 내용을 서버 저장소에 업로드 하기

```
> git push
```

## 깃 서버 저장소의 변경된 내용을 깃 로컬 저장소에 다운로드 하기

```
> git pull
```

## 1일차(2020-12-21,월) ~ 8일차(2020-12-31,목)

- 자바 프로그래밍 오리엔테이션

## 9일차(2021-01-04,월)

- 수업에서 사용할 git 저장소 준비
    - github.com 에 개인 저장소 생성
        - 회원가입
        - bitcamp-study 저장소 생성
    - 로컬에 복제
        - c:/Users/사용자홈폴더/git/bitcamp-study 
    - 강의 자료 저장소 복제
        - github.com/eomcs/eomcs-docs : DB 설치, 개발 도구 사용법 등
        - github.com/eomcs/eomcs-java : 자바 프로그래밍 기본 예제
        - github.com/eomcs/eomcs-java-web : 서블릿/JSP 프로그래밍 예제
        - github.com/eomcs/eomcs-spring-webmvc : Spring WebMVC 예제
        - github.com/eomcs/eomcs-java-project-2020 : 실습 프로젝트
        - github.com/eomcs/eomcs-java-project-2021 : 실습 프로젝트
- 프로그래밍에 대한 소개
    - 컴퓨터(CPU, RAM, HDD 등) + OS + 프로그램 개념

- 학습 목표 달성 확인 목록
    - [] 서버 컴퓨터와 서버 프로그램의 관계를 이해하는가?
    - [] 서버 프로그램과 데스크톱 프로그램을 구분할 수 있는가?
    - [] 클라이언트 프로그램이 무엇인지 이해하고 있는가?
    - [] 클라이언트/서버 구조로 된 애플리케이션의 예를 들 수 있는가?
    - [] git 클라이언트 프로그램을 설치할 수 있는가?
    - [] macOS 패키지 관리자 프로그램인 HomeBrew 를 설치할 수 있는가?
    - [] HomeBrew 패키지 관리자를 통해 git 프로그램을 설치할 수 있는가?
    - [] github.com에서 깃 저장소를 생성할 수 있는가?
    - [] git 서버의 저장소를 로컬로 복제할 수 있는가?
    - [] 로컬에서 작업한 파일을 로컬 깃 저장소에 백업할 수 있는가?
    - [] 로컬 깃 저장소에 백업한 내용을 깃 서버의 저장소에 업로드 할 수 있는가?
    - [] 컴퓨터에서 CPU와 RAM, HDD 의 관계 및 역할을 이해하고 있는가?
    - [] OS의 역할을 대략적으로 이해하는가?
    - [] 명령어를 작성할 때 CPU에 맞춰서 작성해야 하고 또한 OS에 맞춰서 명령어를 구성해야 하는 이유를 설명할 수 있는가?
    - [] 명령어를 작성할 때 컴파일러의 역할은 무엇인가?
    - [] 컴파일러가 OS와 CPU에 따라 구분되는 이유를 아는가?
    - [] 자바 컴파일러가 들어 있는 JDK를 설치할 때 OS와 CPU에 따라 구분해야 하는 이유를 아는가?
    - [] 자바 컴파일러와 JVM의 역할을 설명할 수 있는가?
    - [] 소스(source)와 바이트코드(bytecode)를 설명할 수 있는가?
    - [] 자바 컴파일러를 사용하여 소스 파일을 컴파일 할 수 있는가?
    - [] JVM을 사용하여 바이트코드를 실행할 수 있는가?
    - [] 컴파일 방식과 인터프리터 방식의 차이점과 장단점을 이해하는가?
    - [] 자바는 하이브리드 방식으로 프로그램을 개발하고 실행한다. 하이브리드 방식을 설명할 수 있는가?
    
## 10일차(2021-01-05,화)

- 컴파일 방식 프로그래밍 경험
    - GCC 컴파일러(MinGW) 설치
    - hello.c 소스 작성
    - 컴파일 및 실행
- 인터프리터 방식 프로그래밍 경험
    - Nodejs 설치
    - Hello.js 소스 작성
    - 인터프리터 실행
- JDK와 JRE, JavaSE, JavaEE, JavaME 소개
    - Hello.java 소스 작성
    - 컴파일 및 JVM 실행
- JDK 및 Eclipse IDE 설치 및 설정


- 학습 목표 달성 확인 목록
    - [] 컴파일 방식과, 인터프리터 방식, 하이브리드 방식의 특징을 설명할 수 있는가?
    - [] 컴파일/인터프리터/하이브리드 방식의 예제를 작성하고 실행시킬 수 있는가?
    - [] GUI와 CLI가 무엇인지 알고 있다.
    - [] OS에서 shell 과 Shell Script 의 관계를 이해한다.
    - [] 윈도우 OS에서 '명령프롬프트'와 '파워쉘'의 차이점을 이해한다.
    - [] 해시 값/디지털 지문이 무엇인지 알고 있다.
    - [] 알고리즘의 뜻을 말할 수 있다.
    - [] MD5, SHA-1, SHA256, SHA512, PGP 등이 무엇을 의미하는지 알고 있다.
    - [] Windows/macOS 에서 명령어를 사용하여 해시 코드를 알아 낼 수 있다.
    - [] JDK를 설치하고 환경 변수(JAVA_HOME, PATH)를 설정할 수 있는가?
    - [] Java IDE(Integrated Development Environment, 예: Eclipse)를 설치하고 설정할 수 있는가?


## 11일차(2021-01-06,수)

- 바이트코드 프로그래밍 
    - 직접 바이트코드를 작성해보기
    - 자바 언어를 이용한 프로그래밍의 이점을 이해하기
    - sublime 에디터 설치
    - HelloWorld.class 작성하기
    - https://medium.com/@davethomas_9528/writing-hello-world-in-java-byte-code-34f75428e0ad
- 학습 목표 달성 확인 목록
    - [] bytecode(portable code, p-code) 가 무엇인지 이해하는가?
    - [] 바이트코드를 직접 작성하는 것보다 소스 파일을 작성해서 컴파일하는 것이 낫다는 것을 이해하는가?
    - [] 빌드 도구가 무슨 일을 하는지 알고 있는가?
    - [] 대표적인 자바 빌드 도구의 종류를 말할 수 있는가? 
    - [] 각 빌드 도구의 설정 파일을 구분할 수 있는가?
    - [] 중간 언어를 이용하는 vm 방식과 LLVM 방식의 특징을 이해하는가? 

## 12일차(2021-01-07,목)

- 자바 언어 기초(com.eomcs.lang)
    - ex01 ~ ex03 예제 
- Gradle 빌드 도구 설치
    - gradle.org 사이트에서 다운로드 후 설치 및 설정
    - .gitignore 파일 추가
- 이클립스로 프로젝트 임포트
    
- 학습 목표 달성 확인 목록
    - [] 자바 소스 파일과 class {} 블록, 컴파일러의 관계를 이해하는가?
    - [] 공개 클래스와 디폴트 클래스, 소스 파일명의 관계를 이해하는가?
    - [] 자바 패키지의 목적을 이해하는가?
    - [] 패키지에 소속된 클래스를 정의할 수 있는가?
    - [] 패키지에 소속된 클래스와 무소속 클래스를 컴파일하면 어떻게 되는지 알고 있는가?
    - [] 패키지에 소속된 클래스를 JVM으로 실행할 수 있는가?
    - [] 일반 주석과 javadoc 주석, 애노테이션의 용도를 이해하는가?
    - [] javadoc 프로그램을 사용하여 API 문서를 생성할 수 있는가?
    - [] 메모리와 비트, 2진수의 관계를 이해하는가?
    - [] 비트 크기에 따라 저장할 수 있는 수의 범위를 계산할 수 있는가?
    - [] 메모리에 정수 값을 저장할 때 음수를 어떻게 저장하는지 알고 있는가?
    - [] 2의 보수가 무엇인지 아는가? 2의 보수를 사용하여 양수를 음수로 바꿀 수 있는가?
    - [] 자바 언어에서 정수 리터럴을 4바이트와 8바이트로 구분하여 표현할 수 있는가?
    - [] Gradle 빌드 도구를 설치하고 실행할 수 있는가?
    - [] build.gradle 설정 파일을 작성하고, 플러그인 추가/라이브러리 등록 을 할 수 있는가?
    - [] Gradle을 이용하여 이클립스 설정 파일을 생성할 수 있는가?
    - [] 이클립스에서 프로젝트를 임포트 할 수 있는가? 
    - [] .gitignore 파일의 용도를 알고 있는가?

## 13일차(2021-01-08,금)

- 자바 언어 기초(com.eomcs.lang)
    - ex03 예제 : 리터럴 사용법
    - 정수/부동소수점/문자를 2진수로 표현하는 방법
- 학습 목표 달성 확인 목록
    - [] 정수를 2진수로 표현할 때 Sign-Magnitude, 1의 보수, 2의 보수, Excess-K 각각의  방식으로 표현할 수 있는가?
    - [] 정수를 저장할 때 Sign-Magnitude 가 아닌 2의 보수 방식으로 저장하는 이유를 아는가?
    - [] 값을 2진수로 표현하는 이유는 무엇인가?
    - [] 정수 말고, 2진수로 표현하는 다른 종류의 값을 말할 수 있는가?
    - [] 부동소수점을 리터럴로 표현할 수 있는가?
    - [] 부동소수점을 메모리 크기에 따라 4바이트, 8바이트 리터럴로 구분하여 표현할 수 있는가?
    - [] 부동소수점을 2진수로 표현할 수 있는가?
    - [] 부동소수점의 범위를 유효자릿수로 표현하는 이유를 아는가?
    - [] 4바이트 부동소수점과 8바이트 부동소수점의 유효자릿수는 무엇인가?
    - [] 문자의 2진수 표현을 정의한 것을 무엇이라 부르는가?
    - [] character set의 다양한 종류(ASCII,ISO-8859-1,EUC-KR,조합형,MS949,Unicode,UTF-8,UTF16)와 그 특징을 설명할 수 있는가?
    - [] 자바에서는 UTF-16BE(UCS2)을 기본 character set으로 사용한다는 것을 아는가?


## 14일차(2021-01-11,월)

- 자바 언어 기초(com.eomcs.lang)
    - ex04 예제: 변수 사용법
    - 자바 컴파일러와 JVM에서 Character Set을 다루는 과정
    - 인코딩과 디코딩 개념
    - JVM에서 문자를 출력하는 과정과 폰트의 사용
    - 폰트 및 그림의 래스터 방식과 벡터 방식의 개념
    - 자바에서 문자를 코드화 해서 다루는 방법
    - 변수의 개념과 변수를 선언하는 방법
    - 정수, 부동소수점, 논리, 문자 등 자바 원시 타입 변수를 사용하는 방법
    - 레퍼런스 변수와 자바 원시 타입 변수의 차이점
    - 배열 다루는 방법
    - 인스턴스와 가비지 개념
- 학습 목표 달성 확인 목록
    - [] 컴파일 할 때 -encoding 옵션을 붙여야 하는 경우와 그 이유를 아는가?
    - [] 인코딩과 디코딩을 설명할 수 있는가?
    - [] 폰트가 무엇이고 언제 사용되는지 알고 있는가?
    - [] 래스터 방식 폰트와 벡터 방식 폰트의 구동 원리를 설명할 수 있는가?
    - [] JVM에서 문자를 다루는 방식을 아는가?
    - [] 변수가 무엇인지 설명할 수 있는가? 
    - [] 변수 선언이 무엇인지 설명할 수 있는가?
    - [] 데이터타입과 변수의 관계를 이해하는가?
    - [] 자바 원시 타입의 변수를 선언하고 값을 할당할 수 있는가?
    - [] 자바 원시 타입 변수와 레퍼런스 변수의 차이점을 이해하는가?
    - [] 배열을 생성하고 배열의 각 항목의 값을 다룰 수 있는가?
    - [] 배열을 이용하여 인스턴스와 가비지를 설명할 수 있는가?

## 15일차(2021-01-12,화)

- Application Architecture 소개
    - 애플리케이션 아키텍처의 시대 별 변화 과정
    - 각 아키텍처의 특징과 단점, 그리고 해결책
- SCM(Software Configuration Management) 의 개념
    - 형상 관리 시스템(=버전 관리 시스템) 소개
    - CSV, Subversion, Git 의 차이점 
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 1-a 단계: 자바 프로젝트 폴더 준비
        - gradle 빌드 도구를 사용한다.
        - Maven 빌드 도구의 표준 디렉토리 구조로 프로젝트 폴더를 구성한다.
    - 1-b 단계: 프로젝트를 이클립스 IDE로 임포트 하기
        - build.gradle 파일을 편집한다.
        - `eclipse` 그래이들 플러그인 추가
        - `$ gradle eclipse` 명령을 실행하여 이클립스 IDE 관련 설정 파일을 준비한다.
        - 이클립스에서 프로젝트를 임포트 한다.
    - 1-c 단계: 프로젝트에 버전 관리 시스템 Git을 적용하기
        - `$ git init` 실행 
- 학습 목표 달성 확인 목록
    - [] 시스템 소프트웨어와 애플리케이션 소프트웨어를 설명할 수 있는가?
    - [] 애플리케이션 아키텍처의 종류와 특징을 설명할 수 있는가?
    - [] gradle 빌드 도구를 사용하여 자바 애플리케이션 프로젝트를 구성할 수 있는가?
    - [] gradle을 사용하여 애플리케이션을 실행(run)하고 빌드(build) 할 수 있는가?
    - [] gradle을 사용하여 Eclipse IDE 프로젝트로 전환할 수 있는가?
    - [] 형상 관리 시스템이 무엇인지 알고 있는가?
    - [] CSV, Subversion, Git 버전 관리 시스템의 차이점 이해하고 있는가?
    - [] 프로젝트를 git 저장소로 설정할 수 있는가? 

## 16일차(2021-01-13,수)

- JIT, AOT 컴파일러 소개
- 자바 언어 기초(com.eomcs.lang)
    - ex99 예제: 콘솔 출력 및 키보드 입력을 다루는 방법
    - print(), println(), printf() 사용법
    - Scanner 객체 사용법 
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 1-c 단계: 프로젝트에 버전 관리 시스템 Git을 적용하기(계속)
        - `$ git init` 실행 
        - `.git/` 폴더의 용도 이해
        - github.com 에 저장소 생성
        - 로컬 저장소와 원격 저장소를 연결
        - 로컬 저장소의 변경 내용을 원격 저장소에 업로드
    - 2 단계: 리터럴과 콘솔 출력 다루기
        - `System.out.print()` 사용
        - `System.out.println()` 사용
        - `System.out.printf()` 사용
        - 문자열 리터럴의 연결
    - 3 단계: 변수와 키보드 입력 다루기
        - `Scanner` 객체를 사용하여 키보드 입력 다루기
- 학습 목표 달성 확인 목록
    - [] `.git/` 폴더가 무슨 용도인지 알고 있는가? 
    - [] git 을 이용하여 로컬 저장소에 변경한 내용을 백업할 수 있는가?
    - [] git 로컬 저장소를 원격 저장소와 연결할 수 있는가?
    - [] git 로컬 저장소의 변경 사항을 원격 저장소에 업로드 할 수 있는가?
    - [] 문자열 리터럴을 다룰 수 있는가?
    - [] print(), println(), printf() 메서드를 사용할 수 있는가?
    - [] Scanner 객체를 사용하여 키보드 입력을 다룰 수 있는가?
    - [] C, C++, Java를 비교하여 특징을 간략히 설명할 수 있는가?
    - [] function, class 문법이 등장한 이유를 이해하는가?
    
## 17일차(2021-01-14,목)

- 자바 언어 기초(com.eomcs.lang)
    - ex05 : 연산자 사용법
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 3 단계: 변수와 키보드 입력 다루기 (해설)
- 학습 목표 달성 확인 목록
    - [] 자바에서 제공하는 연산자를 사용할 수 있는가?
    - [] 정수 연산에서 최소 연산 단위가 int임을 이해하는가?
    - [] 연산 우선 순위를 이해하는가?
    - [] 연산은 같은 타입이어야만 수행할 수 있다는 것을 아는가?
    - [] 연산의 결과는 피연산자의 타입과 같다는 것을 아는가?
    - [] 암시적 형변환을 설명할 수 있는가?
    - [] 명시적 형변환을 사용할 수 있는가?
    - [] 부동소수점의 값을 비교할 때 극소수의 값을 고려해야 함을 이해하는가?
    - [] 관계 연산자(>, >=, <, <=, ==, !=)를 다룰 수 있는가?
    - [] 부동소수점의 값을 비교할 때 주의할 사항이 무엇인가?
    - [] 논리 연산자(&&,||,!,^,&,|)를 다룰 수 있는가?
    - [] &&와 &, ||와 | 논리 연산자의 차이점을 아는가?
    - [] 비트 연산자(&,|,^,~)를 다룰 수 있는가?
    - [] 비트 연산자로 % 연산을 수행하는 방법을 아는가?
    - [] 비트 연산자를 활용하여 특정 값만 추출하는 방법을 아는가?
    - [] 비트 연산자를 활용하여 여러 개의 true/false 값을 한 변수에서 다룰 수 있는가?
    - [] 비트 이동 연산자(<<, >>, >>>)를 다룰 수 있는가?
    - [] 비트 이동 연산자를 사용하여 2의 배수를 곱하고 나누는 방법을 아는가?
    - [] 조건 연산자(?:)를 다룰 수 있는가?
    - [] ++/-- 후위 연산자 및 전위 연산자를 다룰 수 있는가?
    - [] 복합 할당 연산자(+=, -=, *=, /=, %= 등)를 다룰 수 있는가?
 
## 18일차(2021-01-15,금)

- 자바 언어 기초(com.eomcs.lang)
    - ex06 : 명령어의 실행 흐름을 제어하는 방법
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 4 단계: 배열과 흐름 제어문 활용하기
    - 5 단계: 프로그램의 시작점(entry point), `main()`
- 학습 목표 달성 확인 목록
    - [] if, if ~ else 문을 사용하여 조건에 따라 흐름을 제어할 수 있는가?
    - [] while, do ~ while, for(;;), for(:) 문을 사용하여 반복 작업을 처리할 수 있는가?
    - [] 프로그램의 엔트리 포인트가 무슨 의미인지 알고 있는가?

## 19일차(2021-01-18,월)

- 자바 언어 기초(com.eomcs.lang)
    - ex07 : 메서드를 활용하여 명령을 기능 단위로 분리하는 방법
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 6 단계: 메서드의 존재 이유
- 학습 목표 달성 확인 목록
    - [] 환경 변수 JAVA_HOME과 PATH를 설정하고 그 용도를 설명할 수 있는가?
    - [] gradle 설정을 통하여 이클립스 프로젝트 이름을 변경할 수 있는가?
    - [] 메서드를 정의할 수 있는가?
    - [] 정의한 메서드를 사용할 수 있는가?
    - [] 메서드 시그너처, 메서드 바디, 파라미터, 아규먼트 용어를 설명할 수 있는가?
    - [] 메서드 문법을 사용했을 때 이점은 무엇인가?
    - [] 리팩토링의 의미가 무엇인지 아는가?
        - 코드를 묶거나 쪼개서 유지보수 하기 좋은 구조로 소스 코드를 정리하는 것!

## 20일차(2021-01-19,화)

- 자바 언어 기초(com.eomcs.lang)
    - ex07 : 메서드를 활용하여 명령을 기능 단위로 분리하는 방법(계속)
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 6 단계: 메서드의 존재 이유(계속)
    - 7 단계: 클래스로 메서드를 분류하기
- 학습 목표 달성 확인 목록
    - [] 메서드를 정의하고 사용할 수 있는가?
    - [] 파라미터와 아규먼트에 대해 설명할 수 있는가?
    - [] call by value 와 call by reference에 대해 예제를 들어 설명할 수 있는가?
    - [] 클래스 문법의 용도를 설명할 수 있는가?
    - [] 역할에 따라 메서드를 분류하여 클래스로 정의할 수 있는가?
    - [] 클래스에 등록된 메서드를 호출할 수 있는가?

## 21일차(2021-01-20,수)

- 자바 언어 기초(com.eomcs.lang)
    - ex07 : 메서드를 활용하여 명령을 기능 단위로 분리하는 방법(보류)
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 7 단계: 클래스로 메서드를 분류하기(계속)
    - 8 단계: 클래스를 이용하여 새 데이터 타입 정의하기
    - 9 단계: 패키지로 클래스를 분류하기
- 학습 목표 달성 확인 목록
    - [] 클래스 문법을 이용하여 새 데이터 타입을 정의할 수 있는가?
    - [] 클래스로 데이터 타입을 정의하여 사용할 때 이점은 무엇인가?
    - [] 인스턴스와 레퍼런스 개념을 이해하는가?
    - [] 클래스의 인스턴스를 생성할 수 있는가?
    - [] 레퍼런스 배열을 생성하고 다룰 수 있는가?
    - [] 인스턴스를 레퍼런스 배열로 다룰 수 있는가?

## 22일차(2021-01-21,목)

- 자바 언어 기초(com.eomcs.lang)
    - ex07 : 메서드를 활용하여 명령을 기능 단위로 분리하는 방법(보류)
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 10 단계: 다른 클래스와 관계 맺기 : 의존 관계
    - 11 단계: 클래스 필드와 클래스 메서드의 한계
- 학습 목표 달성 확인 목록
    - [] UML이 무엇이고 어떤 용도로 사용하는지 아는가?
    - [] 의존 객체(dependency)가 무엇인지 이해하는가?
    - [] GRASP 패턴이 무엇인지 아는가?
    - [] Information Expert 패턴에 대해 이해하는가?
    - [] domain, vo(value object), dto(data transfer object) 클래스의 의미를 이해하는가? 
    - [] 스태틱 필드의 사용 범위와 그 한계를 이해하는가?
    - [] '기술 부채'가 무엇인지 설명할 수 있는가?

## 23일차(2021-01-22,금)

- 자바 언어 기초(com.eomcs.lang)
    - ex07 : 메서드를 활용하여 명령을 기능 단위로 분리하는 방법(보류)
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 12-a 단계: 인스턴스 필드와 인스턴스 메서드가 필요한 이유 : 인스턴스 필드 사용법
    - 12-b 단계: 인스턴스 필드와 인스턴스 메서드가 필요한 이유 : Information Expert 디자인 패턴
    - 12-c 단계: 인스턴스 필드와 인스턴스 메서드가 필요한 이유 : 인스턴스 메서드 도입
- 학습 목표 달성 확인 목록
    - [] 클래스 로딩이 무엇인지 설명할 수 있는가?
    - [] 스태틱 필드와 인스턴스 필드의 생성 시점을 이해하는가?
    - [] Method Area와 Heap, Stack 메모리 영역의 쓰임새를 이해하는가?
    - [] 가비지가 무엇인지 설명할 수 있는가?
    - [] 스태틱 필드의 쓰임새를 아는가?
    - [] 인스턴스 필드의 쓰임새를 아는가?
    - [] 인스턴스 메서드의 쓰임새를 아는가?
    - [] 인스턴스 메서드의 내장 변수인 this를 설명할 수 있는가?

## 24일차(2021-01-25,월)

- 자바 언어 기초(com.eomcs.lang)
    - ex07 : 메서드를 활용하여 명령을 기능 단위로 분리하는 방법(완료)
- 객체지향 문법(com.eomcs.oop)
    - ex01 : 레퍼런스와 인스턴스, 가비지, 가비지 컬렉터 등
    - ex02 : 스태틱 필드/메서드와, 인스턴스 필드/메서드 사용법
    - ex03 : 인스턴스 메서드의 this 내장 변수 용도(Exam0320 까지) 
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 13-a 단계: 의존 객체 주입 : 인스턴스 필드 활용
- 학습 목표 달성 확인 목록
    - [] 가비지의 의미를 알고 있는가?
    - [] 레퍼런스 카운트란 무엇인가?
    - [] 가비지 컬렉터는 무엇인지 알고 있는가?
    - [] 가비지 컬렉터가 실행되는 경우는 언제인가?
    - [] System.gc() 메서드는 무슨 일을 하는가?
    - [] 다섯 가지 객체 관계를 이해하고 UML로 표현할 수 있는가?
    - [] 의존 객체를 설명할 수 있는가?

## 25일차(2021-01-26,화)

- 객체지향 문법(com.eomcs.oop)
    - ex03 : 인스턴스 메서드의 this 내장 변수 용도(Exam0410 부터) 
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 13-b 단계: 의존 객체 주입 : 생성자 활용
- 학습 목표 달성 확인 목록
    - [] 생성자 문법의 용도를 설명할 수 있는가?
    - [] 생성자를 이용하여 인스턴스 필드를 초기화시킬 수 있는가?
    - [] this() 의 용법을 아는가?
    - [] 스태틱 변수 초기화 문장을 사용할 수 있는가?
    - [] 스태틱 블록을 이용하여 스태틱 변수를 초기화시킬 수 있는가?
    - [] 스태틱 블록이 여러 개일 경우 컴파일러가 어떻게 다루는지 아는가?
    - [] 스태틱 변수 초기화 문장이 컴파일되면 어떻게 바뀌는지 아는가?
    - [] 클래스 로딩할 때 어떻게 초기화 과정이 어떻게 진행되는지 이해하는가?
    - [] 인스턴스 블록을 이용하여 인스턴스 변수를 초기화시킬 수 있는가?
    - [] 인스턴스 블록이 컴파일되면 어떻게 바뀌는지 아는가?
    - [] 인스턴스 변수 초기화 문장이 컴파일되면 어떻게 바뀌는지 아는가?
    - [] 인스턴스 블록의 용도를 아는가?

## 26일차(2021-01-27,수)

- 객체지향 문법(com.eomcs.oop)
    - ex04 : 다양한 클래스의 생성자 활용 
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 14 단계: CRUD(Create, Retrieve/Read, Update, Delete) 구현
- 과제 : 개인 프로젝트 중간 발표
- 학습 목표 달성 확인 목록
    - [] JVM의 file.encoding 프로퍼티의 용도를 알고 있는가?
    - [] file.encoding 프로퍼티를 설정하지 않으면 기본 character set 은 무엇인가?
    - [] 클래스 멤버 @Deprecated 애노테이션이 붙은 경우 무엇을 의미하는지 아는가? 
    - [] 생성자의 접근 범위가 private이나 protected 으로 막혔을 때 그 의미를 이해하는가?
    - [] 인스턴스 메서드와 스태틱 메서드의 용도를 이해했는가?
    - [] 상수를 사용하는 이점과 용법을 알고 있는가?
    - [] 배열을 활용하여 생성된 객체(의 주소)를 등록하고, 조회하고, 변경하고, 삭제할 수 있는가?


## 27일차(2021-01-28,목)

- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 14 단계: CRUD(Create, Retrieve/Read, Update, Delete) 구현(계속)
    - 14-x 단계: CRUD(Create, Retrieve/Read, Update, Delete) 구현 - 메뉴 다루기와 역할 분담
- 과제 : 개인 프로젝트 중간 발표(계속)
- 학습 목표 달성 확인 목록
    - [] CRUD 를 구현할 수 있는가?
    - [] 리팩토링 기법 중에서 `extract method`와 `replace temp with query`의 의미를 이해하는가?

## 28일차(2021-01-29,금)

- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 15-a 단계:  데이터 처리 코드를 캡슐화 하기 전 : 배열 크기 늘리기
    - 15-b 단계:  데이터 처리 코드를 캡슐화 하기 전 : 배열 대신 연결리스트 사용하기
- 과제 : 개인 프로젝트 중간 발표(보류)
- 학습 목표 달성 확인 목록
    - [] 배열의 크기를 늘리는 방법을 아는가?
    - [] 배열의 크기를 늘릴 때 문제점을 아는가?
    - [] linked-list 자료 구조의 구동원리를 이해하는가?
    - [] linked-list 자료 구조를 구현할 수 있는가?
    - [] 배열 방식과 linked-list 방식의 특징을 설명할 수 있는가?

## 29일차(2021-02-01,월)

- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 16-a 단계:  데이터 처리 코드를 캡슐화 하기 : 배열 크기 늘리기
    - 16-b 단계:  데이터 처리 코드를 캡슐화 하기 : 배열 크기 늘리기
    - 16-c 단계:  데이터 처리 코드를 캡슐화 하기 : 배열 대신 연결리스트 사용하기
- 과제 : 개인 프로젝트 중간 발표(발표)
- 학습 목표 달성 확인 목록
    - [] 데이터 처리 코드를 별도의 클래스를 분리했을 때 어떤 이점이 있는가?
    - [] `GRASP` 설계 패턴 방법론에서 `High Cohesion` 패턴의 특징을 이해하는가?
    
## 30일차(2021-02-02,화)

- 객체지향 문법(com.eomcs.oop)
    - ex08 : 캡슐화 문법 사용
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 17 단계:  캡슐화와 접근 제어 : 세터(setter) / 게터(getter)
- 학습 목표 달성 확인 목록
    - [] 추상화에 대해 설명할 수 있는가?
    - [] 캡슐화가 무엇인지 설명할 수 있는가?
    - [] 캡슐화를 보조하는 접근 제어 문법을 이해하는가?
    - [] private/(default)/projected/public 의 접근 범위를 설명할 수 있는가?
    - [] getter와 setter를 정의하고 사용할 수 있는가?
    - [] 필드(field)와 프로퍼티(property)의 차이점을 아는가?
    - [] 상속의 의미와 이점을 이해하는가?
    - [] 다형성의 3대 유형을 설명할 수 있는가?
    - [] 다형적 변수를 다룰 수 있는가?
    - [] 오버로딩의 의미와 그 이점을 설명할 수있는가?
    - [] 오버라이딩이 의미와 그 이점을 설명할 수 있는가?

## 31일차(2021-02-03,수)

- 자바 기본 클래스 사용법(com.eomcs.basic)
    - ex01 : 캡슐화 문법 사용
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 18-a 단계: 다형성 활용 : 다형적 변수와 형변환
    - 18-b 단계: 다형성 활용 : 오버라이딩과 오버로딩 
- 학습 목표 달성 확인 목록
    - [] 클래스를 정의할 때 수퍼 클래스를 지정하지 않으면 어떻게 되는지 아는가?
    - [] Object 클래스의 toString() 리턴 값을 이해하는가?
    - [] Object 클래스의 equals(), hashCode() 메서드의 기능을 이해하는가?
    - [] Object 클래스의 메서드를 어떤 상황에서 오버라이딩 해야 하는지 아는가?

## 32일차(2021-02-04,목)

- 객체지향 문법(com.eomcs.oop)
    - ex05 : 상속 문법의 용도 및 사용법
- 자바 기본 클래스 사용법(com.eomcs.basic)
    - ex02 : 문자열, 날짜, 래퍼(wrapper) 클래스 사용법
- 학습 목표 달성 확인 목록
    - [] mutable 객체와 immutable 객체의 차이를 예를 들어 설명할 수 있는가?
    - [] 리터럴로 만든 String 객체와 new 로 만든 String 객체의 차이점을 설명할 수 있는가?
    - [] 래퍼(wrapper) 클래스의 용도와 사용법을 알고 있는가?
    - [] java.util.Date, java.sql.Date, java.util.Calendar 클래스를 사용할 수 있는가?
    - [] 기능을 확장하기 위해 사용하는 기법의 유형을 설명할 수 있는가?
    - [] 상속을 이용하여 기능을 확장할 수 있는가?
    - [] 수퍼 클래스와 서브 클래스의 용어를 이해하는가?
    - [] 상속 관계에 있는 클래스의 인스턴스 생성 과정을 이해하는가?
    - [] 상속 관계에 있는 클래스의 생성자 호출 과정을 이해하는가?
    - [] 수퍼 클래스의 생성자를 호출하는 `super()` 의 사용법을 아는가?
    - [] 자바에서 다중 상속을 지원하지 않는 이유를 아는가?
    - [] specialization과 generalization 상속 기법을 설명할 수 있는가?
    - [] 추상 클래스의 용도와 사용법을 아는가?
    - [] 추상 메서드의 용도와 사용법을 아는가?

## 33일차(2021-02-05,금)

- 객체지향 문법(com.eomcs.oop)
    - ex06 : 다형성의 활용 및 final 사용법
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 19-a 단계: 자료구조 구현과 활용 : 스택 구현과 사용
- 학습 목표 달성 확인 목록
    - [] 다형적 변수를 활용할 수 있는가?
    - [] 컴파일러에서 다형적 변수의 사용 법위를 어디까지 허용하는지 아는가?
    - [] JVM에서 다형적 변수의 사용 범위를 어디까지 허용하는지 아는가?
    - [] 레퍼런스를 타입 캐스팅하는 방법을 아는가?
    - [] final 제한자의 사용법을 아는가?
    - [] 스택과 큐의 구동 원리는 이해하는가?
    - [] 스택과 큐를 언제 적용해야 하는지 예를 들어 설명할 수 있는가?
    - [] 스택을 구현할 수 있는가?


## 34일차(2021-02-08,월)

- 객체지향 문법(com.eomcs.oop)
    - ex08 : 캡슐화에서 protected 활용(복습)
- 자바 기본 클래스 사용법(com.eomcs.basic)
    - ex01 : Exam0170 ~ Exam0175, clone()을 이용한 인스턴스 shallow copy, deep copy
- 알고리즘(com.eomcs.algorithm.data_structure)
    - queue, stack : 큐, 스택 구현 방법 및 사용법(복습)
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 19-a 단계: 자료구조 구현과 활용 : 스택 구현과 사용(계속)
    - 19-b 단계: 자료구조 구현과 활용 : 큐 구현과 사용
    - 20-a 단계: `Iterator` 디자인 패턴 : 데이터 조회 기능을 캡슐화
    - 20-b 단계: `Iterator` 디자인 패턴 : XxxIterator 에 대해 Generalization 수행 
- 학습 목표 달성 확인 목록
    - [] private/(default)/protected/public 접근 제어를 이해하는가?
    - [] 오버라이딩하는 메서드의 리턴 타입이 어디까지 허용되는지 아는가?
    - [] Object의 clone()을 이용하여 인스턴스 복제를 처리할 수 있는가?
    - [] 인스턴스 복제 기능을 활성화시키는 방법을 아는가?
    - [] clone() 메서드를 사용하기 위해 필요한 조치 사항을 아는가?
    - [] 인스턴스 복제에서 shallow copy와 deep copy의 차이점을 아는가?
    - [] 큐를 구현할 수 있는가?
    - [] Iterator 패턴의 특징을 이해하고 구현할 수 있는가?
    - [] 상속의 기법에서 일반화(generalization)와 전문화(specialization)를 구현할 수 있는가?

## 35일차(2021-02-09,화)

- 객체지향 문법(com.eomcs.oop)
    - ex07 : 추상 클래스와 인터페이스 사용법
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 20-c 단계: `Iterator` 디자인 패턴 : Iterator 패턴에 인터페이스 문법 적용
    - 20-d 단계: `Iterator` 디자인 패턴 : GRASP의 Creator 패턴 적용
    - 20-e 단계: `Iterator` 디자인 패턴 : 스태틱 중첩 클래스(static nested class) 활용
    - 20-f 단계: `Iterator` 디자인 패턴 : 논스태틱 중첩 클래스(inner class) 활용
    - 20-g 단계: `Iterator` 디자인 패턴 : 로컬 클래스(local class) 활용
    - 20-h 단계: `Iterator` 디자인 패턴 : 익명 클래스(anonymous class) 활용
- 학습 목표 달성 확인 목록
    - [] 인터페이스 문법을 사용하여 객체 사용 규칙을 정의할 수 있는가?
    - [] GRASP의 Creator 패턴의 원리를 이해하는가?
    - [] 패키지 멤버 클래스를 중첩 클래스로 전환하여 다룰 수 있는가?
    - [] 스태틱 중첩 클래스와 논스태틱 중첩 클래스의 차이점을 아는가?
    - [] 로컬 클래스에서 로컬 변수에 접근하는 방법을 아는가?
    - [] 익명 클래스를 정의할 수 있는가?


## 36일차(2021-02-10,수)

- 객체지향 문법(com.eomcs.oop)
    - ex07 : 추상 클래스와 추상 메서드 사용법(계속)
    - ex09 : 인터페이스 사용법
- 학습 목표 달성 확인 목록
    - [] 추상 클래스를 정의하는 방법과 concrete 클래스와의 차이점을 이해하는가?
    - [] 언제 추상 클래스를 사용해야 하는지 아는가?
    - [] 추상 메서드를 정의할 수 있는가?
    - [] 추상 메서드를 사용해야 하는 상황과 그 의미를 설명할 수 있는가?
    - [] 추상 클래스와 추상 메서드를 활용하여 Template Method 패턴을 구현할 수 있는가?
    - [] Math.random() 메서드의 사용법을 아는가?
    - [] 인터페이스를 정의하는 방법과 구현하는 방법을 아는가?
    - [] 인터페이스 문법을 언제 사용해야 하는지 아는가?
    - [] 인터페이스를 사용했을 때 이점을 이해하는가?
    - [] 인터페이스의 default 메서드의 용도를 설명할 수 있는가?
    - [] 인터페이스의 상속과 다중 상속을 이해하는가?
    - [] 인터페이스의 다중 상속이 불가능한 경우를 설명할 수 있는가? 
    - [] 인터페이스의 구현과 다중 구현을 이해하는가?
    - [] 인터페이스의 다중 구현이 불가능한 경우를 설명할 수 있는가?

## 37일차(2021-02-15,월)

- 객체지향 문법(com.eomcs.oop)
    - ex09 : 인터페이스 사용법(계속)
    - ex11 : 중첩 클래스
- 학습 목표 달성 확인 목록
    - [] 인터페이스를 간접적으로 구현하기 위해 추상 클래스를 활용할 수 있는가?
    - [] 인터페이스를 활용할 수 있는가?
    - [] 인터페이스의 구현을 간결하게 만들기 위해 추상 클래스를 활용할 수 있는가?
    - [] 인터페이스의 default 메서드를 언제 활용하는가?
    - [] 인터페이스의 활용 예를 만들 수 있는가?
    - [] L10N, I18N의 약자를 기술할 수 있는가?
    - [] 스태틱 중첩 클래스를 정의할 수 있는가?
    - [] 논스태틱 중첩 클래스를 정의할 수 있는가?
    - [] inner 클래스가 무엇인지 아는가?
    - [] 스태틱 중첩 클래스와 논스태틱 중첩 클래스의 차이를 아는가?
    - [] 로컬 클래스를 정의할 수 있는가?
    - [] 로컬 클래스에서 바깥 클래스 인스턴스를 주소를 어떻게 관리하는가?
    - [] 로컬 클래스가 바깥 메서드의 로컬 변수를 사용할 때 어떻게 관리하는가?
    - [] 익명 클래스를 정의할 수 있는가?
    - [] 리팩토링과 디자인 패턴의 목적이 무엇인가?
    - [] 
    
## 38일차(2021-02-16,화)

- 제네릭 문법(com.eomcs.generic)
    - ex01 : 제네릭 문법 사용
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 21 단계: 제네릭이 필요한 이유와 사용법
- 학습 목표 달성 확인 목록
    - [] 제네릭 문법을 사용할 때 이점을 설명할 수 있는가?
    - [] 제네릭 문법을 메서드에 적용할 수 있는가?
    - [] 제네릭 문법을 클래스에 적용할 수 있는가?
    - [] 타입 파라미터가 무엇인지 알고 있는가?
    - [] 제네릭 타입의 배열을 생성할 수 있는가?
    - [] 프로젝트에 제네릭을 적용할 수 있는가?

## 39일차(2021-02-17,수)

- 자바 기본 클래스 사용법(com.eomcs.basic)
    - ex03 ~ ex08 : 자바 컬렉션 API 사용법
- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 22 단계: 자바 컬렉션 API 사용하기
    - 23 단계: 예외가 발생했을 때 시스템을 멈추지 않게 하는 방법
- 학습 목표 달성 확인 목록
    - [] ArrayList 클래스를 사용할 수 있는가?
    - [] LinkedList 클래스를 사용할 수 있는가?
    - [] ArrayList와 LinkedList의 차이점을 설명할 수 있는가?
    - [] HashSet 클래스를 사용할 수 있는가?
    - [] Hash 알고리즘에 따라 데이터를 저장하는 방법을 아는가?
    - [] HashSet에 저장할 객체는 반드시 hashCode()와 equals()를 오버라이딩 해야 하는 이유를 아는가?
    - [] HashSet의 값 목록을 조회할 수 있는가?
    - [] HashMap 클래스를 사용할 수 있는가?
    - [] HashMap의 key 목록을 다룰 수 있는가?
    - [] HashMap의 value 목록을 다룰 수 있는가?
    - [] HashMap과 Hashtable의 차이점을 설명할 수 있는가?
    - [] List와 Set, Map의 차이점을 설명할 수 있는가?

## 40일차(2021-02-18,목)

- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 24-a 단계: 'Command' 디자인 패턴을 적용하기 : 적용 전 문제점 확인
    - 24-b 단계: 'Command' 디자인 패턴을 적용하기 : 메서드를 객체로 분리하기
    - 24-c 단계: 'Command' 디자인 패턴을 적용하기 : 인터페이스 문법을 이용하여 핸들러 객체의 사용 규칙을 통일하기
    - 24-d 단계: 'Command' 디자인 패턴을 적용하기 : Map 을 이용한 커맨드 객체 관리
- 학습 목표 달성 확인 목록
    - [] 커맨드 디자인 패턴의 사용처를 설명할 수 있는가?
    - [] 커맨드 패턴을 적용할 수 있는가?
    - [] 커맨드 패턴을 적용할 때 인터페이스 문법의 용도를 이해하는가?
    - [] Map 을 사용하여 객체를 다룰 수 있는가?

## 41일차(2021-02-19,금)

- 제네릭 문법(com.eomcs.generic)
    - ex02 ~ ex04 : 제네릭 문법 사용(계속)
- 객체지향 문법(com.eomcs.oop)
    - ex12 : 람다(lambda) 사용법
- 학습 목표 달성 확인 목록
    - [] 제네릭 문법이 적용된 경우 인스턴스와 레퍼런스의 사용법을 이해하는가?
    - [] 제네릭의 wildcard(?) 문법을 사용할 수 있는가?
    - [] wildcard 문법에서 extends와 super 차이점을 이해하는가?
    - [] 'funtional interface' 를 설명할 수 있는가?
    - [] 람다(lambda) 문법을 사용할 수 있는가?
    - [] 로컬 클래스를 익명 클래스로 바꿀 수 있는가?
    - [] 익명 클래스를 람다 코드로 바꿀 수 있는가?
    - [] 스태틱 메서드를 '메서드 레퍼런스'로 활용할 수 있는가?
    - [] 인스턴스 메서드를 '메서드 레퍼런스'로 활용할 수 있는가?
    - [] 생성자를 '메서드 레퍼런스'로 활용할 수 있는가?
    - [] List의 forEach() 메서드를 활용하여 목록을 조회할 수 있는가?


## 42일차(2021-02-22,월)

- 예외 처리 문법(com.eomcs.exception)
    - 예외 종류와 예외 클래스 계층도의 관계
    - try ~ catch ~ finally 문법의 사용법
    - try with resources 문법의 사용법
- 학습 목표 달성 확인 목록
    - [] 예외의 종류에 무엇이 있는지 아는가?
    - [] 시스템 예외를 다루는 클래스와 애플리케이션 예외를 다루는 클래스를 아는가?
    - [] 시스템 예외 클래스와 애플리케이션 예외 클래스의 계층도를 그릴 수 있는가?
    - [] 예외를 처리하는 try ~ catch ~ 문법을 사용할 수 있는가?
    - [] 여러 개의 catch 블록을 다룰 수 있는가?
    - [] 수퍼 클래스 파라미터로 여러 개의 catch 블록을 한 개의 catch 블록으로 통합하는 방법을 아는가?
    - [] | 연산자를 사용하여 여러 개의 예외를 한 개의 catch 블록에서 받을 수 있는가?
    - [] throw 키워드를 사용하여 예외를 던질 수 있는가?
    - [] 메서드 선언부에 throws 키워드를 언제 사용해야 하는지 아는가?
    - [] 언제 메서드 선언부에 throws 키워드를 생략하는지 아는가?
    - [] Exception과 RuntimeException 예외의 차이를 아는가?
    - [] finally 블록의 사용법을 아는가?
    - [] try-with-resources 문법을 사용할 수 있는가?
    - [] 예외 클래스를 상속 받아 사용자 정의 예외 클래스를 만들 수 있는가?
    - [] 사용자 예외 클래스를 만드는 목적을 아는가?

## 43일차(2021-02-23,화)

- 파일 입출력 API 사용법(com.eomcs.io)
    - File 클래스 사용법
    - FileInputStream/FileOutputStream 클래스 사용법
- 학습 목표 달성 확인 목록
    - [] 내부 기억 장치 RAM과 외부 기억 장치 HDD, SSD의 용도를 이해하는가?
    - [] HDD의 데이터 저장 원리를 이해하는가?
    - [] HDD의 트랙, 섹터, 실린더를 설명할 수 있는가?
    - [] HDD에 데이터를 저장할 때 수평 기록 방식과 수직 기록 방식을 이해하는가?
    - [] 파일 시스템과 디스크 포맷을 설명할 수 있는가?
    - [] File 클래스를 사용하여 파일 및 디렉토리를 생성하고 조회하고 삭제할 수 있는가?
    - [] FileFilter와 FilenameFilter를 사용하여 디렉토리 내용을 선택적으로 조회할 수 있는가?
    - [] FileInputStream/FileOutputStream 클래스를 사용하여 바이트 단위의 데이터를 읽고 쓸 수 있는가?
    - [] 문자열을 특정 문자 집합으로 인코딩 된 바이트 배열로 뽑아낼 수 있는가?

## 44일차(2021-02-24,수)

- 파일 입출력 API 사용법(com.eomcs.io)
    - FileInputStream/FileOutputStream 클래스 사용법(계속)
    - FileReader/FileWriter 클래스 사용법
- 학습 목표 달성 확인 목록
    - [] 바이너리 파일과 텍스트 파일을 구분할 수 있는가?
    - [] 바이트 스트림 클래스와 문자 스트림 클래스를 구분하여 설명할 수 있는가?
    - [] 데이터 싱크(sink) 타입에 따라 클래스를 구분하여 설명할 수 있는가?
    - [] FileInputStream/FileOutputStream으로 텍스트 출력을 다룰 수 있는가?
    - [] FileInputStream/FileOutputStream 클래스와 FileReader/FileWriter 클래스의 사이의 차이점을 이해하는가?
    - [] JVM 환경 변수 "file.encoding" 의 사용법을 아는가?
    - [] 드라이버 소프트웨어가 무엇인지 아는가?
    - [] 스트리밍 API의 등장 이유를 아는가?
    - [] FileReader/FileWriter 사용법
    - [] 데이터 프로세싱 스트림 클래스의 역할을 이해하는가?
    - [] 데이터를 입출력할 때 버퍼를 사용하는 이유를 아는가?
    - [] 파일에서 읽은 1바이트를 4바이트 int 값으로 변환할 때 주의할 점을 아는가?

## 45일차(2021-02-25,목)

- 파일 입출력 API 사용법(com.eomcs.io)
    - 데이터 프로세싱 스트림 클래스 구동원리 이해와 구현
    - 데코레이터 패턴 사용법
    - Java에서 제공하는 데이터 프로세싱 스트림 클래스 사용법
- 학습 목표 달성 확인 목록
    - [] 바이트 배열을 이용하여 데이터를 읽을 때 바이트 배열의 크기는 어느 정도가 적당한가?
    - [] 상속을 이용한 입출력 기능 확장의 한계점을 이해하는가?
    - [] 포함 관계를 통한 기능 확장을 구현할 수 있는가?
    - [] 포함 관계와 상속을 이용하여 데코레이터 패턴을 구현할 수 있는가?
    - [] Java Streamming API의 주요 클래스에 대한 계층도를 그릴 수 있는가?
    - [] serialize(직렬화; 바이트 배열화)의 개념을 이해하는가?
    - [] ObjectInputStream/ObjectOutputStrteam을 이용하여 인스턴스를 입출력 할 수 있는가?
    - [] java.io.Serializable 인터페이스의 용도를 아는가?
    - [] serialize 파일에 출력되는 내용은 무엇인가?
    - [] serialVersionUID 스태틱 필드의 용도를 아는가?
    - [] 파일 입출력을 프로그래밍 할 때 예외처리를 할 수 있는가?

## 46일차(2021-02-26,금)

- 실습 프로젝트 : mini-pms(프로젝트 관리 시스템)
    - 25-a 단계: 파일 입출력 API : 바이너리 형식으로 데이터를 읽고 쓰기(FileInputStream/FileOutputStream)
    - 25-b 단계: 파일 입출력 API : 데코레이터 객체 활용하기(DataInputStream/DataOutputStream)
    - 25-c 단계: 파일 입출력 API : 버퍼 사용하기(BufferedInputStream/BufferedOutputStream)
    - 25-d 단계: 파일 입출력 API : 객체 읽고 쓰기(ObjectInputStream/ObjectOutputStream)
    - 25-e 단계: 파일 입출력 API : 리팩터링 I
- 학습 목표 달성 확인 목록
    - [] 


